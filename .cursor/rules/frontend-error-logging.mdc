---
description: 
globs: 
alwaysApply: false
---
# 프론트엔드 에러 처리 및 로깅 전략: VocaHang

이 문서는 VocaHang (보카맨 프론트엔드) 프로젝트의 에러 처리 및 로깅 전략을 정의합니다. 사용자 경험을 개선하고 문제 발생 시 신속하게 대응하기 위함입니다.

## 1. 에러 처리 (Error Handling)

*   **UI 바운더리 (Error Boundaries)**:
    *   **목표**: React 컴포넌트 트리 내에서 발생하는 JavaScript 오류가 전체 애플리케이션을 중단시키는 것을 방지하고, 사용자에게 친화적인 대체 UI 또는 오류 메시지를 보여줍니다.
    *   **구현**: 주요 레이아웃 영역 또는 독립적으로 기능하는 섹션 단위로 Error Boundary 컴포넌트를 적용합니다. (예: 특정 화면 전체, 게임 플레이 영역 등)
    *   **동작**: 하위 컴포넌트에서 오류 발생 시 `static getDerivedStateFromError()` 및 `componentDidCatch()` 생명주기 메소드를 사용하여 오류를 포착하고, 대체 UI를 렌더링하며 오류 정보를 로깅합니다.

*   **API 요청 오류 처리**:
    *   **목표**: 백엔드 API 호출 시 발생할 수 있는 네트워크 오류, 서버 오류(4xx, 5xx 응답) 등을 적절히 처리하여 사용자에게 상황을 알리고, 필요한 경우 후속 조치를 안내합니다.
    *   **구현**:
        *   `axios` (또는 사용하는 HTTP 클라이언트)의 인터셉터(interceptors) 기능을 활용하여 모든 API 요청/응답에 대한 공통 에러 처리 로직을 구현합니다.
        *   오류 유형(네트워크 단절, 서버 내부 오류, 인증 실패 등)에 따라 사용자에게 명확한 메시지(예: Toast, Alert)를 표시합니다.
        *   필요한 경우, 특정 오류에 대해 재시도(retry) 로직을 구현할 수 있습니다. (예: 일시적인 네트워크 문제)
        *   중요한 API 요청 실패 시, 해당 오류를 로깅 시스템으로 전송합니다.

*   **Promise 기반 비동기 오류 처리**:
    *   **목표**: 애플리케이션 내의 모든 비동기 작업(Promise)에서 발생할 수 있는 오류를 누락 없이 처리합니다.
    *   **구현**:
        *   `async/await` 구문 사용 시: 모든 `await` 호출은 `try...catch` 블록으로 감싸서 오류를 명시적으로 처리합니다.
        *   Promise 체인 (`.then().catch()`) 사용 시: 각 Promise 체인의 마지막에는 항상 `.catch()`를 추가하여 오류를 처리합니다.
        *   처리되지 않은 Promise 거부(unhandled promise rejections)가 발생하지 않도록 주의합니다.

## 2. 로깅 (Logging)

*   **개발 환경 로깅**:
    *   **목표**: 개발 과정에서의 디버깅 효율성을 높이고, 코드 동작을 명확히 이해합니다.
    *   **방법**:
        *   `console.log()`: 변수 값, 객체 상태, 실행 흐름 등 확인.
        *   `console.warn()`: 잠재적인 문제나 개선이 필요한 부분 알림.
        *   `console.error()`: 발생한 오류 정보 출력.
        *   `console.table()`: 배열이나 객체를 테이블 형태로 보기 쉽게 출력.
        *   React DevTools, Redux DevTools 등 개발 도구를 적극 활용합니다.

*   **프로덕션 환경 로깅**:
    *   **목표**: 실제 사용자들이 애플리케이션을 사용하면서 발생하는 오류를 수집하고 분석하여, 문제를 신속하게 파악하고 해결하며 서비스 품질을 개선합니다.
    *   **도구 (원격 로깅 및 에러 트래킹 서비스)**:
        *   **Sentry**: 실시간 오류 추적, 상세한 스택 트레이스, 발생 빈도, 영향받는 사용자 정보 등을 제공합니다. (권장)
        *   **LogRocket**: 오류 추적과 함께 사용자 세션 리플레이 기능을 제공하여, 오류 발생 전후의 사용자 행동을 시각적으로 파악할 수 있습니다.
        *   **Datadog RUM (Real User Monitoring)**: 사용자 경험 모니터링, 성능 지표, 오류 추적 등 종합적인 분석 기능 제공.
    *   **로깅 대상**:
        *   **JavaScript 오류**: Error Boundary에서 포착된 오류, 처리되지 않은 예외, API 요청 실패 시의 클라이언트 측 오류 등. (오류 메시지, 스택 트레이스, 발생 시간, 사용자 정보 - 익명화된 ID, 앱 버전, OS 정보 등 포함)
        *   **주요 사용자 인터랙션 (선택적)**: 문제 해결에 도움이 될 수 있는 주요 기능 사용 흐름 (예: 게임 시작, 레벨 변경, 중요한 설정 변경 등). 개인 식별 정보는 제외하고 익명화된 형태로 로깅.
        *   **API 요청/응답 요약 (선택적, 민감 정보 제외)**: 어떤 API에서 문제가 발생했는지 추적하기 위해 요청 URL, 상태 코드, 응답 시간 등을 로깅. (응답 본문 전체 로깅은 주의)
    *   **구현**: 선택한 원격 로깅 서비스의 SDK를 애플리케이션에 통합하고, 초기화 코드 (`App.tsx` 등)에서 설정합니다. Error Boundary 및 전역 에러 핸들러 등에서 포착된 오류를 해당 서비스로 전송합니다.

## 일반 가이드라인

*   개인 식별 정보(PII)나 민감한 데이터는 절대로 로그에 포함하지 않습니다.
*   로그 레벨(Error, Warn, Info, Debug)을 적절히 사용하여 로그의 중요도를 구분합니다. (프로덕션에서는 주로 Error, Warn 위주로 전송)
*   로그 메시지는 문제 파악에 도움이 되도록 명확하고 충분한 컨텍스트를 포함하도록 작성합니다.
*   정기적으로 수집된 로그를 검토하고, 반복되는 오류나 성능 문제를 개선합니다.

## Cursor AI 협업 가이드라인

*   AI에게 프론트엔드 에러 처리 로직 또는 로깅 관련 코드 생성을 요청할 경우, 본 `frontend-error-logging.mdc` 문서에 정의된 전략(Error Boundaries, API 요청 오류 처리, Sentry 연동 등)을 따르도록 명확히 지시합니다.
*   예시: "프론트엔드 `@VocaHang` 의 특정 컴포넌트에 Error Boundary를 추가하고 싶어. `@VocaHang/.cursor/rules/frontend-error-logging.mdc` 가이드에 따라 Sentry로 오류를 로깅하도록 구현해줘."
*   AI가 생성한 코드가 본 전략을 벗어날 경우, 해당 부분을 지적하고 수정을 요청합니다.
*   **전체 프로젝트 공통 규칙 및 아키텍처는 `Vocaman/PROJECT_COMMON_RULES.mdc` 및 `Vocaman/.cursor/rules/project-architecture-overview.mdc`를 우선적으로 참고해야 합니다.**
